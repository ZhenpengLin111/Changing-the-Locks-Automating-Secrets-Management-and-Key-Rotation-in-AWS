AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Cloud Security Project - Changing the Locks:
  Automated Secrets Management and Key Rotation in AWS with MySQL.

Parameters:
  AdminSecretName:
    Type: String
    Default: CloudSecProject-DbAdminPassword
    Description: Logical name for the Secrets Manager admin secret.
  
  AppUserSecretName:
    Type: String
    Default: CloudSecProject-DbAppUserPassword
    Description: Logical name for the Secrets Manager app user secret.

  RotationIntervalDays:
    Type: Number
    Default: 30
    Description: Number of days between automatic secret rotations.

  LambdaTimeout:
    Type: Number
    Default: 60
    Description: Lambda timeout in seconds.

  TrailName:
    Type: String
    Default: CloudSecProject-Trail
    Description: Name of the CloudTrail trail.

  LogBucketName:
    Type: String
    Description: S3 bucket name for CloudTrail logs (must be globally unique).

  EC2AmiId:
    Type: AWS::EC2::Image::Id
    Default: ami-0fa3fe0fa7920f68e
    Description: AMI ID for EC2 instance (Default here is Amazon Linux 2023).

  EC2InstanceType:
    Type: String
    Default: t3.micro
    Description: EC2 instance type for demo application.

  EC2KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: Name of an existing EC2 KeyPair for SSH access.

  # VPC and Network Parameters
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC ID where resources will be deployed

  PrivateSubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: List of at least 2 private subnet IDs for RDS and Lambda (must be in different AZs)

  PublicSubnetId:
    Type: AWS::EC2::Subnet::Id
    Description: Public subnet ID for EC2 instance

  # MySQL Parameters
  DBUsername:
    Type: String
    Default: admin
    Description: Master username for MySQL database
    NoEcho: true

  DBPassword:
    Type: String
    Default: TempPassword123!
    Description: Initial master password for MySQL (will be rotated)
    NoEcho: true
    MinLength: 8
  
  AppDBUsername:
    Type: String
    Default: app_user
    Description: App username for MySQL database
    NoEcho: true

  AppDBUserPassword:
    Type: String
    Default: TempApp_UserPassword123!
    Description: Initial app user password for MySQL (will be rotated)
    NoEcho: true
    MinLength: 8

  DBInstanceClass:
    Type: String
    Default: db.t4g.micro
    Description: RDS instance class for testing (ARM Graviton2 - cheapest option)
    AllowedValues:
      - db.t4g.micro  # $12/month - Best for continuous testing
      - db.t3.micro   # $15/month - x86 alternative

  DBAllocatedStorage:
    Type: Number
    Default: 20
    Description: Allocated storage in GB
    MinValue: 20
    MaxValue: 100

  EnableCloudWatchLogs:
    Type: String
    Default: 'true'
    Description: Enable CloudWatch logging (adds ~$0.50/month)
    AllowedValues:
      - 'true'
      - 'false'

  BackupRetentionDays:
    Type: Number
    Default: 7
    Description: Days to retain backups (1 = minimum, 7 = recommended)
    MinValue: 1
    MaxValue: 35

  PyMySQLLayerArn:
    Type: String
    Description: ARN of Lambda Layer containing pymysql library

Resources:
  ########################################
  # SECURITY GROUPS
  ########################################

  # Security Group for RDS MySQL
  DBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: CloudSecProject-DBSecurityGroup
      GroupDescription: Security group for MySQL RDS instance
      VpcId: !Ref VpcId
      # Remove SecurityGroupIngress - add separately below
      Tags:
        - Key: Name
          Value: CloudSecProject-DBSecurityGroup

  # Security Group for Lambda
  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: CloudSecProject-LambdaSecurityGroup
      GroupDescription: Security group for Lambda rotation function
      VpcId: !Ref VpcId
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: Allow HTTPS for Secrets Manager API
      Tags:
        - Key: Name
          Value: CloudSecProject-LambdaSecurityGroup

  # Security Group for EC2
  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: CloudSecProject-EC2SecurityGroup
      GroupDescription: Security group for EC2 application instance
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
          Description: SSH access
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: Allow HTTPS for Secrets Manager API
      Tags:
        - Key: Name
          Value: CloudSecProject-EC2SecurityGroup

  # Security Group for VPC Endpoint
  VPCEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: CloudSecProject-VPCEndpointSecurityGroup
      GroupDescription: Security group for Secrets Manager VPC Endpoint
      VpcId: !Ref VpcId
      # Remove SecurityGroupIngress - add separately below
      Tags:
        - Key: Name
          Value: CloudSecProject-VPCEndpointSecurityGroup

  ########################################
  # SECURITY GROUP RULES (Separate to avoid circular dependencies)
  ########################################

  # Allow Lambda to access MySQL
  DBIngressFromLambda:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref DBSecurityGroup
      IpProtocol: tcp
      FromPort: 3306
      ToPort: 3306
      SourceSecurityGroupId: !Ref LambdaSecurityGroup
      Description: Allow Lambda rotation function

  # Allow EC2 to access MySQL
  DBIngressFromEC2:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref DBSecurityGroup
      IpProtocol: tcp
      FromPort: 3306
      ToPort: 3306
      SourceSecurityGroupId: !Ref EC2SecurityGroup
      Description: Allow EC2 application

  # Allow Lambda to reach MySQL
  LambdaEgressToMySQL:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref LambdaSecurityGroup
      IpProtocol: tcp
      FromPort: 3306
      ToPort: 3306
      DestinationSecurityGroupId: !Ref DBSecurityGroup
      Description: Allow outbound to MySQL

  # Allow EC2 to reach MySQL
  EC2EgressToMySQL:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref EC2SecurityGroup
      IpProtocol: tcp
      FromPort: 3306
      ToPort: 3306
      DestinationSecurityGroupId: !Ref DBSecurityGroup
      Description: Allow outbound to MySQL

  # Allow Lambda to reach VPC Endpoint
  VPCEndpointIngressFromLambda:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref VPCEndpointSecurityGroup
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !Ref LambdaSecurityGroup
      Description: Allow Lambda to reach Secrets Manager

  # Allow EC2 to reach VPC Endpoint
  VPCEndpointIngressFromEC2:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref VPCEndpointSecurityGroup
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !Ref EC2SecurityGroup
      Description: Allow EC2 to reach Secrets Manager

  ########################################
  # VPC ENDPOINT FOR SECRETS MANAGER
  ########################################
  SecretsManagerVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref VpcId
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.secretsmanager'
      VpcEndpointType: Interface
      PrivateDnsEnabled: true
      SubnetIds: !Ref PrivateSubnetIds
      SecurityGroupIds:
        - !Ref VPCEndpointSecurityGroup

  ########################################
  # RDS MySQL DATABASE
  ########################################
  
  # DB Subnet Group
  DBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupName: CloudSecProject-DBSubnetGroup
      DBSubnetGroupDescription: Subnet group for MySQL RDS instance
      SubnetIds: !Ref PrivateSubnetIds
      Tags:
        - Key: Name
          Value: CloudSecProject-DBSubnetGroup

  # RDS MySQL Instance
  MySQLDatabase:
    Type: AWS::RDS::DBInstance
    DeletionPolicy: Delete
    Properties:
      DBInstanceIdentifier: cloudsec-mysql-db
      Engine: mysql
      EngineVersion: '8.0.43'
      DBInstanceClass: !Ref DBInstanceClass
      AllocatedStorage: !Ref DBAllocatedStorage
      StorageType: gp2
      MaxAllocatedStorage: 1000
      MasterUsername: !Ref DBUsername
      MasterUserPassword: !Ref DBPassword
      DBName: cloudsecdb
      VPCSecurityGroups:
        - !Ref DBSecurityGroup
      DBSubnetGroupName: !Ref DBSubnetGroup
      BackupRetentionPeriod: 7
      PreferredBackupWindow: '03:00-04:00'
      PreferredMaintenanceWindow: 'sun:04:00-sun:05:00'
      PubliclyAccessible: false
      StorageEncrypted: true
      EnableCloudwatchLogsExports:
        - error
        - general
        - slowquery
      DeletionProtection: false
      Tags:
        - Key: Name
          Value: CloudSecProject-MySQL

  ########################################
  # SECRETS MANAGER ADMIN SECRET (MySQL Format)
  ########################################
  DBAdminSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Ref AdminSecretName
      Description: MySQL admin secret managed by Lambda rotation for Cloud Security project.
      SecretString: !Sub |
        {
          "engine": "mysql",
          "host": "${MySQLDatabase.Endpoint.Address}",
          "username": "${DBUsername}",
          "password": "${DBPassword}",
          "port": ${MySQLDatabase.Endpoint.Port},
          "dbname": "cloudsecdb"
        }

  ########################################
  # SECRETS MANAGER APP USER SECRET (MySQL Format)
  ########################################
  AppDBUserSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Ref AppUserSecretName
      Description: MySQL app user secret managed by Lambda rotation for Cloud Security project.
      SecretString: !Sub |
        {
          "engine": "mysql",
          "host": "${MySQLDatabase.Endpoint.Address}",
          "username": "${AppDBUsername}",
          "password": "${AppDBUserPassword}",
          "port": ${MySQLDatabase.Endpoint.Port},
          "dbname": "cloudsecdb"
        }

  ########################################
  # IAM ROLE FOR ROTATION LAMBDA
  ########################################
  SecretsRotationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: CloudSecProject-SecretsRotationLambdaRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: CloudSecProject-SecretsRotationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Allow Lambda to manage ONLY this project secret
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:PutSecretValue
                  - secretsmanager:DescribeSecret
                  - secretsmanager:UpdateSecretVersionStage
                Resource: 
                  - !Ref DBAdminSecret
                  - !Ref AppDBUserSecret
              
              # Allow Lambda to use the generate random passward API
              - Effect: Allow
                Action:
                  - secretsmanager:GetRandomPassword
                Resource: "*"
              
              # Create a network interface for Lambda in the VPC
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DeleteNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DetachNetworkInterface
                Resource: "*"

              # Allow lambda to update RDS 
              - Effect: Allow
                Action:
                  - rds:ModifyDBInstance
                  - rds:DescribeDBInstances
                Resource: "*"

              # CloudWatch Logs permissions
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  ########################################
  # LAMBDA FUNCTION FOR MySQL SECRET ROTATION
  ########################################
  SecretsRotationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CloudSecProject-MySQLRotationFunction
      Description: MySQL rotation Lambda implementing the 4-step Secrets Manager rotation contract
      Runtime: python3.11
      Handler: index.lambda_handler
      Timeout: !Ref LambdaTimeout
      Role: !GetAtt SecretsRotationLambdaRole.Arn
      Layers:
        - !Ref PyMySQLLayerArn
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds: !Ref PrivateSubnetIds
      Environment:
        Variables:
          EXCLUDE_CHARACTERS: "/@\"'\\"
          PASSWORD_LENGTH: '32'
          ADMIN_SECRET_ARN: !Ref DBAdminSecret
      Code:
        ZipFile: |
          # Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
          # SPDX-License-Identifier: MIT-0

          # Modified by Zhenpeng Lin, 2025

          import boto3
          import json
          import logging
          import os
          import pymysql

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)


          def lambda_handler(event, context):
              """Secrets Manager RDS MySQL Handler

              This handler uses the single-user rotation scheme to rotate an RDS MySQL user credential. This rotation scheme
              logs into the database as the user and rotates the user's own password, immediately invalidating the user's
              previous password.

              The Secret SecretString is expected to be a JSON string with the following format:
              {
                  'engine': <required: must be set to 'mysql'>,
                  'host': <required: instance host name>,
                  'username': <required: username>,
                  'password': <required: password>,
                  'dbname': <optional: database name>,
                  'port': <optional: if not specified, default port 3306 will be used>
              }

              Args:
                  event (dict): Lambda dictionary of event parameters. These keys must include the following:
                      - SecretId: The secret ARN or identifier
                      - ClientRequestToken: The ClientRequestToken of the secret version
                      - Step: The rotation step (one of createSecret, setSecret, testSecret, or finishSecret)

                  context (LambdaContext): The Lambda runtime information

              Raises:
                  ResourceNotFoundException: If the secret with the specified arn and stage does not exist

                  ValueError: If the secret is not properly configured for rotation

                  KeyError: If the secret json does not contain the expected keys

              """
              arn = event['SecretId']
              token = event['ClientRequestToken']
              step = event['Step']

              # Setup the client
              service_client = boto3.client('secretsmanager')

              # Make sure the version is staged correctly
              metadata = service_client.describe_secret(SecretId=arn)
              if "RotationEnabled" in metadata and not metadata['RotationEnabled']:
                  logger.error("Secret %s is not enabled for rotation" % arn)
                  raise ValueError("Secret %s is not enabled for rotation" % arn)
              versions = metadata['VersionIdsToStages']
              if token not in versions:
                  logger.error("Secret version %s has no stage for rotation of secret %s." % (token, arn))
                  raise ValueError("Secret version %s has no stage for rotation of secret %s." % (token, arn))
              if "AWSCURRENT" in versions[token]:
                  logger.info("Secret version %s already set as AWSCURRENT for secret %s." % (token, arn))
                  return
              elif "AWSPENDING" not in versions[token]:
                  logger.error("Secret version %s not set as AWSPENDING for rotation of secret %s." % (token, arn))
                  raise ValueError("Secret version %s not set as AWSPENDING for rotation of secret %s." % (token, arn))

              # Call the appropriate step
              if step == "createSecret":
                  create_secret(service_client, arn, token)

              elif step == "setSecret":
                  set_secret(service_client, arn, token)

              elif step == "testSecret":
                  test_secret(service_client, arn, token)

              elif step == "finishSecret":
                  finish_secret(service_client, arn, token)

              else:
                  logger.error("lambda_handler: Invalid step parameter %s for secret %s" % (step, arn))
                  raise ValueError("Invalid step parameter %s for secret %s" % (step, arn))


          def create_secret(service_client, arn, token):
              """Generate a new secret

              This method first checks for the existence of a secret for the passed in token. If one does not exist, it will generate a
              new secret and put it with the passed in token.

              Args:
                  service_client (client): The secrets manager service client

                  arn (string): The secret ARN or other identifier

                  token (string): The ClientRequestToken associated with the secret version

              Raises:
                  ValueError: If the current secret is not valid JSON

                  KeyError: If the secret json does not contain the expected keys

              """
              # Make sure the current secret exists
              current_dict = get_secret_dict(service_client, arn, "AWSCURRENT")

              # Now try to get the secret version, if that fails, put a new secret
              try:
                  get_secret_dict(service_client, arn, "AWSPENDING", token)
                  logger.info("createSecret: Successfully retrieved secret for %s." % arn)
              except service_client.exceptions.ResourceNotFoundException:
                  # Generate a random password
                  current_dict['password'] = get_random_password(service_client)

                  # Put the secret
                  service_client.put_secret_value(SecretId=arn, ClientRequestToken=token, SecretString=json.dumps(current_dict), VersionStages=['AWSPENDING'])
                  logger.info("createSecret: Successfully put secret for ARN %s and version %s." % (arn, token))


          def set_secret(service_client, arn, token):
              """Set the pending secret in the database

              This method tries to login to the database with the AWSPENDING secret and returns on success. If that fails, it
              tries to login with the AWSCURRENT and AWSPREVIOUS secrets. If either one succeeds, it sets the AWSPENDING password
              as the user password in the database. Else, it throws a ValueError.

              Args:
                  service_client (client): The secrets manager service client

                  arn (string): The secret ARN or other identifier

                  token (string): The ClientRequestToken associated with the secret version

              Raises:
                  ResourceNotFoundException: If the secret with the specified arn and stage does not exist

                  ValueError: If the secret is not valid JSON or valid credentials are found to login to the database

                  KeyError: If the secret json does not contain the expected keys

              """
              try:
                  previous_dict = get_secret_dict(service_client, arn, "AWSPREVIOUS")
              except (service_client.exceptions.ResourceNotFoundException, KeyError):
                  previous_dict = None
              current_dict = get_secret_dict(service_client, arn, "AWSCURRENT")
              pending_dict = get_secret_dict(service_client, arn, "AWSPENDING", token)

              # First try to login with the pending secret, if it succeeds, return
              conn = get_connection(pending_dict)
              if conn:
                  conn.close()
                  logger.info("setSecret: AWSPENDING secret is already set as password in MySQL DB for secret arn %s." % arn)
                  return

              # Make sure the user from current and pending match
              if current_dict['username'] != pending_dict['username']:
                  logger.error("setSecret: Attempting to modify user %s other than current user %s" % (pending_dict['username'], current_dict['username']))
                  raise ValueError("Attempting to modify user %s other than current user %s" % (pending_dict['username'], current_dict['username']))

              # Make sure the host from current and pending match
              if current_dict['host'] != pending_dict['host']:
                  logger.error("setSecret: Attempting to modify user for host %s other than current host %s" % (pending_dict['host'], current_dict['host']))
                  raise ValueError("Attempting to modify user for host %s other than current host %s" % (pending_dict['host'], current_dict['host']))

              # Now try the current password
              conn = get_connection(current_dict)

              # If both current and pending do not work, try previous
              if not conn and previous_dict:
                  # Update previous_dict to leverage current SSL settings
                  previous_dict.pop('ssl', None)
                  if 'ssl' in current_dict:
                      previous_dict['ssl'] = current_dict['ssl']

                  conn = get_connection(previous_dict)

                  # Make sure the user/host from previous and pending match
                  if previous_dict['username'] != pending_dict['username']:
                      logger.error("setSecret: Attempting to modify user %s other than previous valid user %s" % (pending_dict['username'], previous_dict['username']))
                      raise ValueError("Attempting to modify user %s other than previous valid user %s" % (pending_dict['username'], previous_dict['username']))
                  if previous_dict['host'] != pending_dict['host']:
                      logger.error("setSecret: Attempting to modify user for host %s other than previous host %s" % (pending_dict['host'], previous_dict['host']))
                      raise ValueError("Attempting to modify user for host %s other than previous host %s" % (pending_dict['host'], previous_dict['host']))

              # If we still don't have a connection, raise a ValueError
              if not conn:
                  logger.error("setSecret: Unable to log into database with previous, current, or pending secret of secret arn %s" % arn)
                  raise ValueError("Unable to log into database with previous, current, or pending secret of secret arn %s" % arn)


              """ Check if currently rotating admin or app user secret """

              is_admin = current_dict['username'] == "admin"
              if is_admin:
                  """ Rotating admin secret """
                  
                  logger.info("setSecret: Rotating admin secret")
                  # Now set the password to the pending password
                  try:
                      with conn.cursor() as cur:
                          # Use cursor() to run SQL statements
                          cur.execute("SELECT VERSION()")
                          ver = cur.fetchone()
                          password_option = get_password_option(ver[0])
                          cur.execute("SET PASSWORD = " + password_option, pending_dict['password'])
                          conn.commit()
                          logger.info("setSecret: Successfully set password for admin %s in MySQL DB for secret arn %s." % (pending_dict['username'], arn))
                  finally:
                      conn.close()
              else:
                  """ Rotating non-admin secret """

                  conn.close()  # Close the user connection

                  logger.info("setSecret: Rotating non-admin secret")

                  # Get admin secret arn
                  admin_secret_arn = os.environ["ADMIN_SECRET_ARN"]
                  if not admin_secret_arn:
                      logger.error("setSecret: ADMIN_SECRET_ARN environment variable not set")
                      raise ValueError("ADMIN_SECRET_ARN environment variable not set")

                  # Get the current admin secret
                  current_admin_dict = get_secret_dict(service_client, admin_secret_arn, "AWSCURRENT")

                  # Try to login with current admin secret
                  admin_conn = get_connection(current_admin_dict)

                  if not admin_conn:
                      logger.error("setSecret: Unable to log into database with current admin secret of secret arn %s" % admin_secret_arn)
                      raise ValueError("Unable to log into database with current admin secret of secret arn %s" % admin_secret_arn)

                  # Now set the password to the pending password
                  try:
                      with admin_conn.cursor() as cur:
                          # Use cursor() to run SQL statements
                          username = pending_dict['username']
                          password = pending_dict['password']
                          cur.execute("ALTER USER %s@'%%' IDENTIFIED BY %s", (username, password))
                          admin_conn.commit()
                          logger.info("setSecret: Successfully set password for user %s in MySQL DB for secret arn %s." % (pending_dict['username'], arn))
                  finally:
                      admin_conn.close()

          def test_secret(service_client, arn, token):
              """Test the pending secret against the database

              This method tries to log into the database with the secrets staged with AWSPENDING and runs
              a permissions check to ensure the user has the corrrect permissions.

              Args:
                  service_client (client): The secrets manager service client

                  arn (string): The secret ARN or other identifier

                  token (string): The ClientRequestToken associated with the secret version

              Raises:
                  ResourceNotFoundException: If the secret with the specified arn and stage does not exist

                  ValueError: If the secret is not valid JSON or valid credentials are found to login to the database

                  KeyError: If the secret json does not contain the expected keys

              """
              # Try to login with the pending secret, if it succeeds, return
              conn = get_connection(get_secret_dict(service_client, arn, "AWSPENDING", token))
              if conn:
                  # This is where the lambda will validate the user's permissions. Uncomment/modify the below lines to
                  # tailor these validations to your needs
                  try:
                      with conn.cursor() as cur:
                          cur.execute("SELECT NOW()")
                          conn.commit()
                  finally:
                      conn.close()

                  logger.info("testSecret: Successfully signed into MySQL DB with AWSPENDING secret in %s." % arn)
                  return
              else:
                  logger.error("testSecret: Unable to log into database with pending secret of secret ARN %s" % arn)
                  raise ValueError("Unable to log into database with pending secret of secret ARN %s" % arn)


          def finish_secret(service_client, arn, token):
              """Finish the rotation by marking the pending secret as current

              This method finishes the secret rotation by staging the secret staged AWSPENDING with the AWSCURRENT stage.

              Args:
                  service_client (client): The secrets manager service client

                  arn (string): The secret ARN or other identifier

                  token (string): The ClientRequestToken associated with the secret version

              """
              # First describe the secret to get the current version
              metadata = service_client.describe_secret(SecretId=arn)
              current_version = None
              for version in metadata["VersionIdsToStages"]:
                  if "AWSCURRENT" in metadata["VersionIdsToStages"][version]:
                      if version == token:
                          # The correct version is already marked as current, return
                          logger.info("finishSecret: Version %s already marked as AWSCURRENT for %s" % (version, arn))
                          return
                      current_version = version
                      break

              # Finalize by staging the secret version current
              service_client.update_secret_version_stage(SecretId=arn, VersionStage="AWSCURRENT", MoveToVersionId=token, RemoveFromVersionId=current_version)
              # Remove AWSPENDING from the new current version
              service_client.update_secret_version_stage(
                  SecretId=arn,
                  VersionStage="AWSPENDING",
                  RemoveFromVersionId=token
              )
              logger.info("finishSecret: Successfully set AWSCURRENT and remove AWSPENDING stages to version %s for secret %s." % (token, arn))


          def get_connection(secret_dict):
              """Gets a connection to MySQL DB from a secret dictionary

              This helper function uses connectivity information from the secret dictionary to initiate
              connection attempt(s) to the database. Will attempt a fallback, non-SSL connection when
              initial connection fails using SSL and fall_back is True.

              Args:
                  secret_dict (dict): The Secret Dictionary

              Returns:
                  Connection: The pymysql.connections.Connection object if successful. None otherwise

              Raises:
                  KeyError: If the secret json does not contain the expected keys

              """
              # Parse and validate the secret JSON string
              port = int(secret_dict['port']) if 'port' in secret_dict else 3306
              dbname = secret_dict['dbname'] if 'dbname' in secret_dict else None

              # Get SSL connectivity configuration
              use_ssl, fall_back = get_ssl_config(secret_dict)

              # if an 'ssl' key is not found or does not contain a valid value, attempt an SSL connection and fall back to non-SSL on failure
              conn = connect_and_authenticate(secret_dict, port, dbname, use_ssl)
              if conn or not fall_back:
                  return conn
              else:
                  return connect_and_authenticate(secret_dict, port, dbname, False)


          def get_ssl_config(secret_dict):
              """Gets the desired SSL and fall back behavior using a secret dictionary

              This helper function uses the existance and value the 'ssl' key in a secret dictionary
              to determine desired SSL connectivity configuration. Its behavior is as follows:
                  - 'ssl' key DNE or invalid type/value: return True, True
                  - 'ssl' key is bool: return secret_dict['ssl'], False
                  - 'ssl' key equals "true" ignoring case: return True, False
                  - 'ssl' key equals "false" ignoring case: return False, False

              Args:
                  secret_dict (dict): The Secret Dictionary

              Returns:
                  Tuple(use_ssl, fall_back): SSL configuration
                      - use_ssl (bool): Flag indicating if an SSL connection should be attempted
                      - fall_back (bool): Flag indicating if non-SSL connection should be attempted if SSL connection fails

              """
              # Default to True for SSL and fall_back mode if 'ssl' key DNE
              if 'ssl' not in secret_dict:
                  return True, True

              # Handle type bool
              if isinstance(secret_dict['ssl'], bool):
                  return secret_dict['ssl'], False

              # Handle type string
              if isinstance(secret_dict['ssl'], str):
                  ssl = secret_dict['ssl'].lower()
                  if ssl == "true":
                      return True, False
                  elif ssl == "false":
                      return False, False
                  else:
                      # Invalid string value, default to True for both SSL and fall_back mode
                      return True, True

              # Invalid type, default to True for both SSL and fall_back mode
              return True, True


          def connect_and_authenticate(secret_dict, port, dbname, use_ssl):
              """Attempt to connect and authenticate to a MySQL instance

              This helper function tries to connect to the database using connectivity info passed in.
              If successful, it returns the connection, else None

              Args:
                  - secret_dict (dict): The Secret Dictionary
                  - port (int): The databse port to connect to
                  - dbname (str): Name of the database
                  - use_ssl (bool): Flag indicating whether connection should use SSL/TLS

              Returns:
                  Connection: The pymongo.database.Database object if successful. None otherwise

              Raises:
                  KeyError: If the secret json does not contain the expected keys

              """
              ssl = {'ca': '/etc/pki/tls/cert.pem', } if use_ssl else None

              # Try to obtain a connection to the db
              try:
                  # Checks hostname and verifies server certificate implictly when 'ca' key is in 'ssl' dictionary
                  conn = pymysql.connect(host=secret_dict['host'], user=secret_dict['username'], password=secret_dict['password'], port=port, database=dbname, connect_timeout=5, ssl=ssl)
                  logger.info("Successfully established %s connection as user '%s' with host: '%s'" % ("SSL/TLS" if use_ssl else "non SSL/TLS", secret_dict['username'], secret_dict['host']))
                  return conn
              except pymysql.OperationalError as e:
                  if 'certificate verify failed: IP address mismatch' in e.args[1]:
                      logger.error("Hostname verification failed when estlablishing SSL/TLS Handshake with host: %s" % secret_dict['host'])
                  return None


          def get_secret_dict(service_client, arn, stage, token=None):
              """Gets the secret dictionary corresponding for the secret arn, stage, and token

              This helper function gets credentials for the arn and stage passed in and returns the dictionary by parsing the JSON string

              Args:
                  service_client (client): The secrets manager service client

                  arn (string): The secret ARN or other identifier

                  token (string): The ClientRequestToken associated with the secret version, or None if no validation is desired

                  stage (string): The stage identifying the secret version

              Returns:
                  SecretDictionary: Secret dictionary

              Raises:
                  ResourceNotFoundException: If the secret with the specified arn and stage does not exist

                  ValueError: If the secret is not valid JSON

              """
              required_fields = ['host', 'username', 'password']

              # Only do VersionId validation against the stage if a token is passed in
              if token:
                  secret = service_client.get_secret_value(SecretId=arn, VersionId=token, VersionStage=stage)
              else:
                  secret = service_client.get_secret_value(SecretId=arn, VersionStage=stage)
              plaintext = secret['SecretString']
              secret_dict = json.loads(plaintext)

              # Run validations against the secret
              supported_engines = ["mysql", "aurora-mysql"]
              if 'engine' not in secret_dict or secret_dict['engine'] not in supported_engines:
                  raise KeyError("Database engine must be set to 'mysql' in order to use this rotation lambda")
              for field in required_fields:
                  if field not in secret_dict:
                      raise KeyError("%s key is missing from secret JSON" % field)

              # Parse and return the secret JSON string
              return secret_dict


          def get_password_option(version):
              """Gets the password option template string to use for the SET PASSWORD sql query

              This helper function takes in the mysql version and returns the appropriate password option template string that can
              be used in the SET PASSWORD query for that mysql version.

              Args:
                  version (string): The mysql database version

              Returns:
                  PasswordOption: The password option string

              """
              if version.startswith("8"):
                  return "%s"
              else:
                  return "PASSWORD(%s)"


          def get_environment_bool(variable_name, default_value):
              """Loads the environment variable and converts it to the boolean.

              Args:
                  variable_name (string): Name of environment variable

                  default_value (bool): The result will fallback to the default_value when the environment variable with the given name doesn't exist.

              Returns:
                  bool: True when the content of environment variable contains either 'true', '1', 'y' or 'yes'
              """
              variable = os.environ.get(variable_name, str(default_value))
              return variable.lower() in ['true', '1', 'y', 'yes']


          def get_random_password(service_client):
              """ Generates a random new password. Generator loads parameters that affects the content of the resulting password from the environment
              variables. When environment variable is missing sensible defaults are chosen.

              Supported environment variables:
                  - EXCLUDE_CHARACTERS
                  - PASSWORD_LENGTH
                  - EXCLUDE_NUMBERS
                  - EXCLUDE_PUNCTUATION
                  - EXCLUDE_UPPERCASE
                  - EXCLUDE_LOWERCASE
                  - REQUIRE_EACH_INCLUDED_TYPE

              Args:
                  service_client (client): The secrets manager service client

              Returns:
                  string: The randomly generated password.
              """
              passwd = service_client.get_random_password(
                  ExcludeCharacters=os.environ.get('EXCLUDE_CHARACTERS', '/@"\'\\'),
                  PasswordLength=int(os.environ.get('PASSWORD_LENGTH', 32)),
                  ExcludeNumbers=get_environment_bool('EXCLUDE_NUMBERS', False),
                  ExcludePunctuation=get_environment_bool('EXCLUDE_PUNCTUATION', False),
                  ExcludeUppercase=get_environment_bool('EXCLUDE_UPPERCASE', False),
                  ExcludeLowercase=get_environment_bool('EXCLUDE_LOWERCASE', False),
                  RequireEachIncludedType=get_environment_bool('REQUIRE_EACH_INCLUDED_TYPE', True)
              )
              return passwd['RandomPassword']

  ########################################
  # ALLOW SECRETS MANAGER TO INVOKE LAMBDA
  ########################################
  SecretsManagerInvokeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SecretsRotationFunction
      Action: lambda:InvokeFunction
      Principal: secretsmanager.amazonaws.com

  ########################################
  # ROTATION SCHEDULE FOR ADMIN SECRET
  ########################################
  ProjectSecretRotationSchedule:
    Type: AWS::SecretsManager::RotationSchedule
    DependsOn:
      - SecretsManagerInvokeLambdaPermission
      - MySQLDatabase
    Properties:
      SecretId: !Ref DBAdminSecret
      RotationLambdaARN: !GetAtt SecretsRotationFunction.Arn
      RotationRules:
        AutomaticallyAfterDays: !Ref RotationIntervalDays
  
  ########################################
  # ROTATION SCHEDULE FOR APP USER SECRET
  ########################################
  AppDBUserRotationSchedule:
    Type: AWS::SecretsManager::RotationSchedule
    DependsOn:
      - SecretsManagerInvokeLambdaPermission
      - MySQLDatabase
    Properties:
      SecretId: !Ref AppDBUserSecret          
      RotationLambdaARN: !GetAtt SecretsRotationFunction.Arn
      RotationRules:
        AutomaticallyAfterDays: !Ref RotationIntervalDays

  ########################################
  # IAM ROLE FOR APPLICATION TO READ SECRET
  ########################################
  AppSecretsReadRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: CloudSecProject-AppSecretsReadRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: CloudSecProject-AppSecretsReadPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:DescribeSecret
                Resource: !Ref AppDBUserSecret

  ########################################
  # INSTANCE PROFILE FOR EC2 APPLICATION
  ########################################
  AppInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: CloudSecProject-AppInstanceProfile
      Roles:
        - !Ref AppSecretsReadRole

  ########################################
  # EC2 INSTANCE (DEMO APPLICATION)
  ########################################
  AppEC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref EC2InstanceType
      ImageId: !Ref EC2AmiId
      IamInstanceProfile: !Ref AppInstanceProfile
      SubnetId: !Ref PublicSubnetId
      SecurityGroupIds:
        - !Ref EC2SecurityGroup
      KeyName: !Ref EC2KeyName
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          sudo dnf install python3-pip -y

          # Install mysql client
          sudo dnf install -y mariadb105

          # Install AWS SDK
          pip3 install boto3 pymysql
          
          # Create a simple test script
          cat > /home/ec2-user/test_db_connection.py << 'EOF'
          import boto3
          import json
          import pymysql
          
          region_name = "us-east-1"
          # Get secret from Secrets Manager
          client = boto3.client('secretsmanager', region_name)
          secret = client.get_secret_value(SecretId='${AppDBUserSecret}')
          creds = json.loads(secret['SecretString'])
          
          # Connect to MySQL
          conn = pymysql.connect(
              host=creds['host'],
              user=creds['username'],
              password=creds['password'],
              database=creds['dbname'],
              port=creds['port']
          )
          
          print("Successfully connected to MySQL!")
          cursor = conn.cursor()
          cursor.execute("SELECT VERSION()")
          version = cursor.fetchone()
          print(f"MySQL version: {version[0]}")
          conn.close()
          EOF
          
          chown ec2-user:ec2-user /home/ec2-user/test_db_connection.py
          
          echo "Setup complete! Test with: python3 /home/ec2-user/test_db_connection.py"
      Tags:
        - Key: Name
          Value: CloudSecProject-AppInstance

  ########################################
  # CLOUDTRAIL + S3 LOGGING
  ########################################
  CloudTrailLogBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref LogBucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  CloudTrailLogBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref CloudTrailLogBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AWSCloudTrailAclCheck
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Action: "s3:GetBucketAcl"
            Resource: !Sub arn:aws:s3:::${CloudTrailLogBucket}
          - Sid: AWSCloudTrailWrite
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Action: "s3:PutObject"
            Resource: !Sub arn:aws:s3:::${CloudTrailLogBucket}/AWSLogs/${AWS::AccountId}/*
            Condition:
              StringEquals:
                s3:x-amz-acl: bucket-owner-full-control

  CloudSecTrail:
    Type: AWS::CloudTrail::Trail
    DependsOn: CloudTrailLogBucketPolicy
    Properties:
      TrailName: !Ref TrailName
      S3BucketName: !Ref CloudTrailLogBucket
      IsLogging: true
      IsMultiRegionTrail: true
      IncludeGlobalServiceEvents: true

Outputs:
  AdminSecretArn:
    Description: ARN of the managed MySQL admin secret.
    Value: !Ref DBAdminSecret

  AppUserSecretArn:
    Description: ARN of the managed MySQL app user secret.
    Value: !Ref AppDBUserSecret

  MySQLEndpoint:
    Description: MySQL database endpoint
    Value: !GetAtt MySQLDatabase.Endpoint.Address

  MySQLPort:
    Description: MySQL database port
    Value: !GetAtt MySQLDatabase.Endpoint.Port

  RotationLambdaName:
    Description: Name of the Lambda rotation function.
    Value: !Ref SecretsRotationFunction

  AppRoleArn:
    Description: IAM Role ARN for applications that read the secret.
    Value: !GetAtt AppSecretsReadRole.Arn

  AppInstanceId:
    Description: ID of the EC2 instance using the AppInstanceProfile.
    Value: !Ref AppEC2Instance

  AppInstancePublicIP:
    Description: Public IP of the EC2 instance
    Value: !GetAtt AppEC2Instance.PublicIp

  CloudTrailBucket:
    Description: S3 bucket where CloudTrail logs are stored.
    Value: !Ref CloudTrailLogBucket

  TestConnectionCommand:
    Description: Command to test database connection from EC2
    Value: python3 /home/ec2-user/test_db_connection.py